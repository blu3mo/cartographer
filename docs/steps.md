システム設計書に基づき、ウェブサービス「Cartographer」を実装するためのマクロな手順を3つのフェーズに分けて提案します。各フェーズの終わりには、動作確認が可能な明確なマイルストーンを設定します。

---

### Phase 1: コア機能と基本フローの実装

**目標:** ホストがセッションを作成でき、参加者がそれに参加して一通り回答を完了できる、サービスの最も基本的なサイクルを完成させます。

このフェーズが完了すると、**「セッションの作成 → 参加 → 回答 → データ保存」**という中核機能が動作するようになります。

#### 📝 やることリスト

1.  **開発環境のセットアップ**
    * **Next.jsプロジェクト作成**: `create-next-app` を使用してプロジェクトの雛形を生成します。
    * **ライブラリのインストール**: `tailwindcss`, `@supabase/supabase-js` (DBアクセス用), `axios` (APIクライアント) などをインストールします。
    * **Neon DBの準備**: Neonでプロジェクトを作成し、データベース接続文字列（DATABASE\_URL）を取得します。
    * **環境変数設定**: `.env.local`ファイルを作成し、`DATABASE_URL`とOpenRouterの`API_KEY`を設定します。

2.  **データベーススキーマの定義とマイグレーション**
    * Supabase（PostgreSQL）のSQLエディタなどで、設計書に記載されている `sessions`, `statements`, `participants`, `responses` の4つのテーブルを定義します。
        * *注意: レポート関連のテーブル (`situation_analysis_reports`, `individual_reports`) は後のフェーズで追加します。*
    * Supabaseのマイグレーション（SQLファイル）を適用し、Neon/Supabase上にテーブルを作成します。

3.  **バックエンドAPIの実装 (コア部分)**
    * **ユーザー識別ロジック**:
        * クライアントの `localStorage` に `cartographer_user_id` がなければUUIDを生成して保存する処理をフロントエンドの共通部分（`_app.tsx`など）に実装します。
        * APIリクエスト時に `Authorization: Bearer <user_id>` ヘッダーからIDを抜き出すためのヘルパー関数、またはミドルウェアを作成します。
    * **セッション作成API (`POST /api/sessions`)**:
        * リクエストボディ (`title`, `context`) とヘッダーの`user_id`を受け取ります。
        * `sessions` テーブルにデータを保存します。
        * **LLM連携**: OpenRouter APIを呼び出し、「初期ステートメント生成プロンプト」を用いて15個のステートメントを生成させます。
        * LLMからのJSONレスポンスをパースし、`statements` テーブルに保存します。
    * **参加者向けAPI**:
        * **参加登録 (`POST /api/sessions/[sessionId]/participants`)**: `name` と `user_id` で `participants` テーブルにレコードを作成します。
        * **次のStatement取得 (`GET /api/sessions/[sessionId]/statements/next`)**: 指定された参加者がまだ回答していないStatementを1件取得するロジックを実装します。
        * **回答送信 (`POST /api/sessions/[sessionId]/responses`)**: `statementId` と `value` を受け取り、`responses` テーブルに回答を記録します。

4.  **フロントエンドUIの実装 (コア部分)**
    * **セッション作成ページ (`/sessions/new`)**:
        * 設計書通りのシンプルなフォームを作成し、作成ボタン押下で `POST /api/sessions` を呼び出します。
        * 成功したら、管理画面 (`/sessions/[sessionId]/admin`) にリダイレクトします（この時点ではページは空でOK）。
    * **セッション参加ページ (`/sessions/[sessionId]`)**:
        * ユーザーの参加状況に応じた状態管理 (`'NEEDS_NAME'`, `'ANSWERING'`, `'COMPLETED'`) をReactの `useState` を用いて実装します。
        * 名前入力フォームを作成し、参加登録APIを呼び出します。
        * Statement回答用のカードコンポーネントを作成し、5つの回答ボタンを配置します。
        * ボタンクリックで回答送信APIを呼び出し、成功後に次のStatement取得APIを呼び出してカード内の表示を更新する、という一連の流れを実装します。

#### ✅ Phase 1 完了チェックリスト

* [ ] `/sessions/new` ページからセッションを作成できるか？
* [ ] セッション作成時にLLMが15個のステートメントを自動生成し、DBに保存されているか？
* [ ] 参加ページ (`/sessions/[sessionId]`) を開き、名前を入力してセッションに参加できるか？
* [ ] Statementが1つずつ表示され、5つの選択肢から回答できるか？
* [ ] 全てのStatementに回答し終えると、「完了」メッセージが表示されるか？
* [ ] Neon DBの `responses` テーブルに、送信した回答が正しく記録されているか？

---

### Phase 2: ホスト向け管理画面と全体分析機能の実装

**目標:** ホストがセッションの結果を一覧し、分析できる管理画面を完成させます。LLMを活用した最初の分析レポート生成機能を実装します。

このフェーズが完了すると、**収集したデータを可視化し、最初の洞察を得る**ことができるようになります。

#### 📝 やることリスト

1.  **データベーススキーマの追加**
    * Supabaseに `situation_analysis_reports` テーブルを追加するSQLを適用します。
    * 反映後、DBスキーマを更新して整合性を確認します。

2.  **バックエンドAPIの実装 (管理画面向け)**
    * **管理画面データ取得API (`GET /api/sessions/[sessionId]/admin`)**:
        * リクエストヘッダーの `user_id` がセッションの `host_user_id` と一致するか検証する認可処理を実装します。
        * **統計処理**: 各Statementに紐づく全回答を `responses` テーブルから集計し、`strongYes`, `yes` などの割合や `agreementScore` を計算するロジックを実装します。SupabaseのクエリやSQL集計を活用します。
        * 最新の `SituationAnalysisReport` も取得し、`SessionAdminData` 型のオブジェクトを構築して返します。
    * **現状分析レポート生成API (`POST /api/sessions/[sessionId]/reports/situation-analysis`)**:
        * 認可処理を実装します。
        * DBからレポート生成に必要なデータ（`context`、回答統計付きStatement一覧）を収集します。
        * **LLM連携**: 収集したデータを整形してプロンプトに埋め込み、「現状分析レポート生成プロンプト」を用いてOpenRouter APIを呼び出します。
        * 返ってきたMarkdown形式のレポートを `situation_analysis_reports` テーブルに保存し、クライアントに返します。

3.  **フロントエンドUIの実装 (管理画面)**
    * **管理画面ページ (`/sessions/[sessionId]/admin`)**:
        * ページ読み込み時に `GET /api/sessions/[sessionId]/admin` APIを呼び出し、`SessionAdminData` を取得します。
        * **コントロールパネル**: 「現状分析レポートを生成する」ボタンを配置し、API呼び出し中のローディング状態を管理するロジックを実装します。
        * **レポート表示エリア**: 取得した最新レポートを `react-markdown` などのライブラリを使って表示します。
        * **Statement一覧**:
            * 取得した `statements` をループして表示します。
            * 各Statementの回答割合を可視化する**横棒グラフ**コンポーネントを、設計書通り `flex` と `div` で作成します。
            * 「合意度順」などで一覧を並び替えるソート機能をフロントエンド側で実装します。

#### ✅ Phase 2 完了チェックリスト

* [ ] 作成者以外が管理画面URLにアクセスすると、エラー（403 Forbidden）になるか？
* [ ] 管理画面にStatement一覧が表示され、回答状況が横棒グラフで正しく可視化されているか？
* [ ] 複数の参加者が回答した後、グラフの割合が正しく更新されるか？
* [ ] Statement一覧のソート機能が意図通りに動作するか？
* [ ] 「現状分析レポートを生成する」ボタンを押すと、LLMによるレポートが生成され、DBに保存されるか？
* [ ] 生成されたレポートが管理画面にMarkdownとしてきれいに表示されるか？

---

### Phase 3: 高度なLLM連携とUXの向上

**目標:** 議論を深めるための「新規ステートメント生成」機能と、参加者の自己理解を促す「じぶんレポート」機能を実装し、サービス全体の体験を向上させます。

このフェーズが完了すると、**Cartographerの独自機能がすべて実装され、実用的なサービスとして完成**します。

#### 📝 やることリスト

1.  **データベーススキーマの最終更新**
    * Supabaseに `individual_reports` テーブルを追加するSQLを適用します。
    * `participants` テーブルに `latest_individual_report_id` カラム（`individual_reports.id` への外部キー）を追加します。
    * マイグレーションを実行し、変更を反映します。

2.  **バックエンドAPIの実装 (高度な機能)**
    * **新規ステートメント生成API (`POST /api/sessions/[sessionId]/statements/generate`)**:
        * 認可処理を実装します。
        * LLMに渡すためのデータ（`context`、既存Statement一覧、最新の現状分析レポート）をDBから取得します。
        * **LLM連携**: 「新規ステートメント生成プロンプト」でAPIを呼び出し、返ってきたJSONをパースして `statements` テーブルに保存します。
    * **「じぶんレポート」生成・更新API (`POST /api/sessions/[sessionId]/individual-report/update`)**:
        * `user_id` をもとに、対象参加者の全回答履歴を `responses` テーブルから取得します。
        * **LLM連携**: 回答履歴とセッションの `context` を「じぶんレポート生成プロンプト」に渡し、APIを呼び出します。
        * 結果を `individual_reports` テーブルに保存し、そのIDを `participants` テーブルの `latest_individual_report_id` にも記録します。
    * **セッション参加ページ情報取得API (`GET /api/sessions/[sessionId]`) の更新**:
        * 参加者情報を取得する際に、`latest_individual_report_id` を使って最新の「じぶんレポート」もJOINして取得するように修正します。

3.  **フロントエンドUIの実装 (最終)**
    * **管理画面 (`/sessions/[sessionId]/admin`)**:
        * コントロールパネルに「新しいStatementを10個生成する」ボタンを追加し、APIを呼び出す機能を実装します。
        * APIから新しいStatementが返ってきたら、既存の一覧にそれを追加して再描画します。
    * **セッション参加ページ (`/sessions/[sessionId]`)**:
        * 「じぶんレポート」セクションを実装します。
        * ページ読み込み時にレポートデータがあれば表示し、なければ「生成待ち」のメッセージを表示します。
        * 「レポートを更新」ボタンを配置し、クリックで `individual-report/update` APIを呼び出す機能を実装します。ローディング状態も管理します。
    * **トップページ (`/`) の作成**:
        * 設計書にある `GET /api/sessions` を実装し、参加可能なセッションの一覧をカード形式で表示するシンプルなトップページを作成します。

4.  **全体的なUX向上**
    * **ローディング表現**: API通信中にはスピナーやスケルトンスクリーンを表示し、ユーザーが待機状態であることを明確に伝えます。
    * **エラーハンドリング**: API呼び出しが失敗した場合に、トースト通知などでユーザーにエラーをフィードバックする仕組みを導入します。
    * **レスポンシブ対応**: Tailwind CSSのブレークポイントを使い、スマートフォンなどのモバイルデバイスでも快適に操作できるようにレイアウトを調整します。

#### ✅ Phase 3 完了チェックリスト

* [ ] 管理画面で「新しいStatementを生成する」ボタンを押すと、10個の新しいStatementが生成され、一覧に追加されるか？
* [ ] 参加ページで「レポートを更新」ボタンを押すと、LLMによる「じぶんレポート」が生成・表示されるか？
* [ ] 一度生成したレポートは、次回ページを読み込んだ際に最初から表示されているか？
* [ ] トップページに参加可能なセッションの一覧が表示されているか？
* [ ] 各画面でデータ取得中のローディング表現は適切か？
* [ ] APIエラーが発生した際に、ユーザーに分かりやすく通知されるか？
* [ ] スマートフォンで表示した際に、レイアウト崩れがなく操作しやすいか？

以上の3フェーズで進めることで、手戻りを少なくし、各段階で着実に動作するものを積み上げていくことができます。頑張ってください！
