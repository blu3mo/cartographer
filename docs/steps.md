### Cartographer: マクロ実装手順 🗺️

#### Step 1: プロジェクト基盤の構築
1.  **Next.jsプロジェクトのセットアップ**: `create-next-app`を使い、TypeScriptとTailwind CSSを導入したプロジェクトを作成します。
2.  **Neon DBとの接続**: Neonでプロジェクトを作成し、接続情報を環境変数 (`.env.local`) に設定します。PrismaなどのORMを導入し、DBとの接続を確立します。
3.  **DBスキーマの初期定義とマイグレーション**: `sessions`と`statements`テーブルのスキーマをPrismaスキーマファイルに定義し、`prisma migrate dev`でデータベースに反映させます。
4.  **テスト (Step 1)**:
    * Next.jsのトップページが正常に表示されることを確認します。
    * 簡単なAPIルート (`/api/health`) を作成し、DB接続が成功することを示すレスポンス (`{ status: 'ok' }`) が返ることをテストします。

---

#### Step 2: セッション作成フローの実装 (ホスト側)
1.  **セッション作成APIの実装**: `POST /api/sessions` を作成します。リクエストボディから`title`と、テーマや目的をまとめた`context`テキストを受け取り、`sessions`テーブルにレコードを作成します。この時点では、LLMによる初期ステートメント生成は**モックデータ**（固定の10個の質問）を返すように実装します。
2.  **セッション作成UIの実装**: セッションのテーマ・目的・背景情報などを入力する複数のフォームを用意し、送信時にそれらを結合して`context`としてAPIに渡します。作成後、セッションIDと管理用秘密鍵 (`hostSecretKey`) を表示します。
3.  **テスト (Step 2)**:
    * APIエンドポイントを直接叩き、DBに`sessions`と`statements`（モック）が正しく保存されることを確認します。
    * UIからセッションを作成し、成功レスポンス（IDと秘密鍵）が画面に表示されることを手動でテストします。

---

#### Step 3: 回答フローの実装 (参加者側)
1.  **ユーザー識別ロジックの実装**: `localStorage`にユニークIDを保存・取得する簡単なカスタムフック (`useUserId`) を作成します。
2.  **参加登録APIとUIの実装**: `POST /api/sessions/[sessionId]/participants`を実装します。名前を入力するUIを作成し、APIを叩いて`participants`テーブルにレコードを作成します。
3.  **ステートメント取得・回答APIの実装**: `GET /api/sessions/[sessionId]/statements/next`と`POST /api/sessions/[sessionId]/responses`を実装します。
4.  **回答UIの実装**: セッションページで、名前を入力 → ステートメントが1つ表示される → 5段階評価で回答 → 次のステートメントが表示される、という一連の流れをUIとして構築します。
5.  **テスト (Step 3)**:
    * 異なるブラウザ（またはシークレットウィンドウ）で同じセッションにアクセスし、それぞれが別の参加者として扱われることを確認します。
    * 参加者がステートメントに回答し、`responses`テーブルにデータが正しく記録されることを確認します。
    * すべての質問に回答すると、次の質問が表示されなくなることを確認します。

---

#### Step 4: 管理画面の基本機能実装
1.  **管理画面データ取得APIの実装**: `GET /api/sessions/[sessionId]/admin`を実装します。秘密鍵をクエリパラメータで検証し、セッションに紐づく全ステートメントと、各ステートメントの**回答数集計ロジック**を実装して返します。
2.  **管理画面UIの実装**: 取得したデータを元に、ステートメント一覧とそれぞれの回答割合を示すシンプルなバーグラフを表示するページを作成します。この時点ではソート機能は不要です。
3.  **テスト (Step 4)**:
    * 複数の参加者が回答した後、管理画面で表示される回答の集計結果が正しいことを確認します。
    * 不正な秘密鍵でアクセスした場合に、エラーが返ることを確認します。

---

#### Step 5: LLM連携機能の実装
1.  **LLM APIクライアントの準備**: OpenRouter経由で`google/gemini-2.5-pro`を呼び出すためのHTTPクライアント（fetch/axiosなど）を用意します。OpenRouterのAPIキーを環境変数（例: `OPENROUTER_API_KEY`）に設定し、共通ラッパー関数で`Authorization: Bearer`ヘッダーと`HTTP-Referer`/`X-Title`など必要なヘッダーを組み立てます。
2.  **初期ステートメント生成のLLM化**: Step 2でモックにしていた部分を、OpenRouter APIへ`google/gemini-2.5-pro`モデルを指定して呼び出す処理に置き換えます。
3.  **「現状分析レポート」生成APIの実装**: `POST /api/sessions/[sessionId]/reports/situation-analysis`を実装します。DBから必要な情報を集め、設計書通りのプロンプトでOpenRouter経由の`google/gemini-2.5-pro`を呼び出し、結果を`situation_analysis_reports`テーブルに保存します。
4.  **管理画面へのレポート生成ボタン追加**: 管理画面に「現状分析レポート生成」ボタンを設置し、対応するAPIを叩くようにします。生成中はローディング表示を出し、完了したらレポート内容を表示します。
5.  **テスト (Step 5)**:
    * セッション作成時に、意図した通りの初期ステートメントがGemini 2.5 Proによって生成されるか確認します。
    * 管理画面のボタンを押し、レポートが生成されてDBに保存され、画面に表示されるまでの一連の流れをテストします。プロンプトと生成結果が期待通りか、OpenRouterのレート制限やエラー処理が適切に扱えているかを確認します。

---

#### Step 6: 追加機能とUIの改善
1.  **「新規ステートメント生成」機能の実装**: 「現状分析レポート」と同様に、API (`POST /api/sessions/[sessionId]/statements/generate`) とUIのボタンを実装します。
2.  **「じぶんレポート」機能の実装**: 参加者画面に更新ボタンと表示エリアを設け、API (`POST /api/sessions/[sessionId]/individual-report/update`) を実装します。
3.  **管理画面のソート機能実装**: 回答統計データ（合意度、Yesの割合など）を計算するロジックをバックエンドに追加し、フロントエンドでそのデータに基づいてステートメントをソートできるようにします。
4.  **テスト (Step 6)**:
    * 各生成ボタンを押し、DBと画面に新しいデータ（ステートメントやレポート）が正しく反映されることを確認します。
    * 管理画面のソート機能が、計算ロジック通りに正しく動作することを確認します。

---

#### Step 7: 全体調整とデプロイ
1.  **全体的なUI/UXの改善**: ローディング状態、エラー表示、遷移などを全体的に見直し、ユーザー体験を向上させます。
2.  **デプロイ準備**: Vercelなどのホスティングサービスにデプロイする準備をします。環境変数の設定などを本番用に構成します。
3.  **デプロイと最終テスト**: Vercelにデプロイし、本番環境で全ての機能が一通り動作するか最終確認を行います。
4.  **テスト (Step 7)**:
    * 本番URLにアクセスし、開発環境と同じように動作することを確認します。特に、環境変数に依存する機能（DB接続、LLM APIキー）が正しく設定されているか重点的にチェックします。
