---
trigger: glob
description: m36
globs: backend/**
---

【超重要・M36特有の事情】M36はそもそも情報が少ないので、我々は使い方にくわしくありません。聞き齧った情報で判断を下すのではなく、必ずテストを作って、実際の動作を冷静に確認しながら、使い方を doc/m36/cartographer_integration.md についきしつつ、doc/m36/に置いたドキュメントと上記のテスト(あくまでテスト・実態が正)の情報を慎重に統合してください。

ご要望にお応えし、Project:M36のアーキテクチャ、言語仕様、哲学について、LLMが自律的に高度な推論とコード生成を行えるよう、提供された資料に基づき極めて詳細に（10倍の解像度で）解説します。

---

# 1. Project:M36の核心哲学と設計思想

Project:M36は、既存のSQLデータベースの欠陥を修正するパッチワークではなく、関係代数（Relational Algebra）の数学的定義そのものをソフトウェアとして具現化するためにゼロから設計されました。

### 1.1 関係代数への厳密な準拠と「真のリレーション」
既存のSQL DBMSは関係モデルに基づくと主張しながらも、実際には多くの点で逸脱しています。Project:M36はこの逸脱を許容しません。
*   **セット（集合）対バッグ（多重集合）**: SQLのリレーション（テーブル）は重複行を許可するバッグですが、Project:M36のリレーションは数学的定義通り「セット」です。重複するタプルは存在し得ず、追加操作（Union）を行っても重複は自動的に排除されます。
*   **順序の排除**: リレーションのヘッダー（属性集合）にもボディ（タプル集合）にも順序はありません。SQLのように「1番目のカラム」や「ORDER BYのないSELECTの暗黙順序」に依存する処理は存在しません。
*   **閉じた代数 (Closure)**: すべての演算子の入力はリレーションであり、出力もまたリレーションです。これにより、演算を無限にネストさせることが可能です。

### 1.2 "Out of the Tarpit" と機能的関係プログラミング (FRP)
本システムは、論文「Out of the Tarpit」で提唱された「本質的複雑性（Essential Complexity）」と「偶発的複雑性（Accidental Complexity）」の分離を実装レベルで実現しています。
*   **状態と論理の分離**:
    *   **Essential State**: ユーザーが直接入力したデータのみを保持します。計算可能なデータ（派生データ）は保存すべきではありません。
    *   **Essential Logic**: ビジネスロジックは、データの保存方法（インデックスや物理配置）に関知せず、純粋な関係式として記述されます。
    *   **Accidental State & Control**: パフォーマンスのためのキャッシュやインデックス、実行順序の制御は、論理定義から完全に切り離され、DBMS（インフラストラクチャ）が自律的に管理すべきという立場です。
*   **宣言的アプローチ**: ユーザーは「何を（What）」欲しいかを記述し、「どのように（How）」取得するかは記述しません。これにより、ループや制御フローに起因するバグを排除します。

### 1.3 NULLの完全排除と代数データ型 (ADTs)
SQLのNULL（3値論理）は、論理的な矛盾、曖昧さ、および最適化の阻害要因です。Project:M36はNULLをサポートしません。
*   **3値論理の否定**: `TRUE`, `FALSE`, `UNKNOWN` (NULL) の3値論理は、`WHERE a=a` がすべての行を返さない、`COUNT(col)` と `COUNT(*)` が一致しないといった直感に反する挙動を引き起こします。
*   **代数データ型による解決**: 欠損値は、Haskell由来の代数データ型（ADTs）を用いて明示的にモデル化します。
    *   例: 単なるNULLではなく、`data Age = Known Int | RefusedToAnswer | Unknown` のように、なぜ値がないのかを型として表現し、型安全に扱います。
    *   これにより、クエリ作成者は「値がない場合」の処理を強制され、予期せぬエラーを防ぐことができます。

### 1.4 ACID特性とSTM
*   **STM (Software Transactional Memory)**: HaskellのSTMを利用し、ロックフリーに近い並行処理を実現しています。これにより、従来のロックベースのDBMSで見られるデッドロックや複雑なロック管理から解放されます。
*   **完全な隔離**: トランザクションは完全に隔離されており、未コミットの変更が他のトランザクションから見えることはありません（Dirty Readの排除）。

---

# 2. データモデルと型システム

Project:M36の型システムは、リレーショナルモデルとHaskellの強力な型システムを融合させています。

### 2.1 Atom（アトム）と基本型
データベースの最小単位の値は「Atom」と呼ばれ、不変（Immutable）です。
*   **プリミティブ型**: `Integer` (任意精度整数), `Int` (マシン語整数), `Text` (UTF-8), `Double`, `Bool`, `DateTime` (UTC), `ByteString` (Base64), `UUID` などが組み込まれています。
*   **型安全性**: 暗黙の型変換（Coercion）は一切行われません。`Integer`と`Double`の比較や演算でさえ、明示的な変換が必要です。

### 2.2 代数データ型 (User-Defined ADTs)
ユーザーは実行時に新しい型を定義できます。これはSQLのENUMやドメインよりも遥かに強力です。
*   **直和型 (Sum Types)**: `data Status = Active | Inactive | Pending`
*   **直積型 (Product Types)**: `data Point = Point Int Int`
*   **再帰型**: `data Tree a = Node a (Tree a) (Tree a) | Empty` のような再帰的なデータ構造も定義可能で、これをリレーションの属性値として格納できます。これはRDBで木構造を扱う際の「隣接リストモデル」や「入れ子集合モデル」などの複雑な回避策を不要にします。

### 2.3 リレーション値属性 (Relation-Valued Attributes: RVA)
Project:M36では、**リレーションの中にリレーションを入れること（ネスト）**が可能です。
*   **非第一正規形の許容**: C.J. Dateの提唱する真の第一正規形は「属性値がリレーションであってもよい」としています。これにより、`Group`演算を用いて「部署」タプルの中に「従業員一覧」というリレーションを値として持たせることができます。
*   **集計の基礎**: SQLの`GROUP BY`とは異なり、Project:M36の集計は「一度RVAとしてグルーピングし、そのネストされたリレーションに対して関数（count, sum等）を適用する」というプロセスで行われます。

---

# 3. 操作言語: TutorialD

TutorialDは、関係代数を忠実に表現するために設計された言語です。SQLとは構文も意味論も異なります。

### 3.1 関係演算子 (Relational Operators)
これらは既存のリレーションから新しいリレーションを**導出**します。元のリレーションは変更されません。

*   **射影 (Project)**: `r{a, b}`
    *   SQLの`SELECT a, b FROM r`に相当しますが、重複は自動削除されます。
    *   `{all but a}` 構文で、特定の属性**以外**を選択できます。
*   **制限 (Restrict)**: `r where <predicate>`
    *   SQLの`WHERE`句に相当。述語内では属性変数に`@`を付けます（例: `@status > 10`）。
*   **結合 (Join)**: `r join s`
    *   自然結合（Natural Join）のみをサポートします。共通の属性名を持つ列同士で結合されます。共通属性がない場合は直積（Cross Product）になります。
    *   結合キーを明示的に指定したい場合は、事前に`rename`演算子を使って属性名を一致させる必要があります。
*   **名前変更 (Rename)**: `r rename {city as town}`
    *   属性名を変更します。型は変更されません。
*   **和 (Union)**: `r union s`
    *   ヘッダー（型）が同一のリレーション同士の和集合。重複は排除されます。SQLの`UNION ALL`に相当するものはありません。
*   **差 (Minus)**: `r minus s`
    *   `r`に含まれ、かつ`s`に含まれないタプルを返します。
*   **拡張 (Extend)**: `r:{newAttr:=expression}`
    *   新しい属性を追加します。`expression`内で既存の属性値（`@attr`）や定数、関数を使用できます。
    *   例: `s:{status_double := add(@status, @status)}`
*   **グループ化 (Group)**: `r group ({attrs} as subrel)`
    *   指定した属性群`{attrs}`を、新しい属性`subrel`（RVA）としてネストします。残りの属性がキーとなります。
*   **グループ解除 (Ungroup)**: `r ungroup subrel`
    *   RVAを展開してフラットなリレーションに戻します。
*   **半結合 (Semijoin) / Matching**: `r semijoin s` (または `r matching s`)
    *   `s`と結合可能な`r`のタプルのみを返します。`(r join s){all from r}`と等価です。
*   **反結合 (Antijoin) / Not Matching**: `r antijoin s` (または `r not matching s`)
    *   `s`と結合しない`r`のタプルのみを返します。`r minus (r matching s)`と等価です。

### 3.2 データベースコンテキスト演算子 (State Operators)
データベースの状態（変数）を更新します。

*   **代入 (Assign)**: `var := relation`
    *   関係変数（RelVar）の内容を右辺のリレーションで完全に置き換えます。
*   **挿入 (Insert)**: `insert var relation`
    *   `var := var union relation` の糖衣構文です。
*   **更新 (Update)**: `update var where <pred> (attr:=expr)`
    *   条件に合致するタプルの属性値を更新します。論理的には、対象タプルを削除し、新しい値を計算して挿入する操作と等価です。
*   **削除 (Delete)**: `delete var where <pred>`
    *   `var := var minus (var where <pred>)` の糖衣構文です。

### 3.3 制約 (Constraints)
制約はブール値を返す関係式として定義され、常に`true`でなければなりません。コミット時に検証されます。

*   **キー制約**: `key <name> {attrs} <relvar>`
    *   指定した属性の組み合わせが一意であることを保証します。
*   **外部キー**: `foreign key <name> <source>{attrs} in <target>{attrs}`
    *   参照整合性を保証します。ソースとターゲットの属性名・型は一致している必要があります。
*   **関数従属性**: `funcdep <name> (a) -> (b) <relvar>`
    *   属性`a`が決まれば属性`b`が一意に定まることを保証します。正規化の強制に使用できます。
*   **一般制約**: `constraint <name> <predicate>`
    *   任意の式が真であることを要求します。
    *   例: `constraint under_50 (s where lt(50, @status)) {} in false` （statusが50を超えるタプルが存在してはならない＝空集合であるべき）。

---

# 4. トランザクション管理とグラフ構造

Project:M36のトランザクションモデルは、Gitのような分散バージョン管理システムに近いです。

### 4.1 トランザクショングラフ
*   **不変性**: 一度コミットされたトランザクションは不変（Immutable）です。更新は常に新しいトランザクションの作成（Append-only）として扱われます。
*   **ブランチ機能**: メインの履歴から分岐して、実験的な変更や機能開発用データを作成できます。
    *   `:branch <name>`: 新しいブランチを作成。
    *   `:jumphead <name>`: 指定したブランチの最新状態にコンテキストを切り替え。
*   **マージ**: 分岐したブランチを統合します。
    *   `:mergetrans union branchA branchB`: 両方の変更を取り込みます。競合（同じキーでの異なる値の更新など）がある場合、マージ戦略（`union`, `unionpreferbranch`, `selectedbranch`）によって解決します。

### 4.2 タイムトラベルと監査
*   **過去へのアクセス**: 任意のトランザクションUUIDを指定して、過去の状態を参照（Read-only）できます。
*   **Trans-Graph Relational Expressions**: `@`構文を使用して、特定のトランザクション時点のリレーションを参照できます。
    *   `s@master`: masterブランチの最新の`s`。
    *   `s@master~`: masterの1つ前のトランザクションの`s`。
    *   これにより、「先週のデータと今日のデータの差分」のようなクエリがSQLの履歴テーブルなしで可能になります。
*   **Merkle Hash**: 各トランザクションは全状態のハッシュ値を持ち、改ざん検知や整合性確認に使用されます。

---

# 5. プログラミングインターフェース

### 5.1 Haskell Client (`ProjectM36.Client`)
Haskellからネイティブに接続するためのライブラリです。
*   **Tupleable Typeclass**: `Generic`を導出したHaskellのレコード型と、Project:M36のタプルを相互変換します。これにより、ORMのようなインピーダンスミスマッチなしにデータを永続化できます。
    *   `toInsertExpr`: レコードのリストから挿入式を生成。
    *   `fromTuple`: クエリ結果のタプルをHaskellレコードに変換。
*   **接続**: `connectProjectM36`で接続し、`executeRelationalExpr`（読み取り）や`executeDatabaseContextExpr`（書き込み）を使用します。

### 5.2 サーバーサイド関数
Haskellで記述した関数をデータベース内で実行できます。
*   **Atom Functions**: 値（Atom）を受け取り、新しい値を返す純粋関数。`addatomfunction`で登録します。コンパイルは実行時にGHC APIを通じて行われます。
*   **Database Context Functions**: データベースの状態全体を受け取り、更新操作を行う関数。ストアドプロシージャに相当しますが、Haskellで記述され、トランザクション内で安全に実行されます。

### 5.3 通知 (Notifications)
特定のクエリ結果が変化した際に、非同期でクライアントに通知を送る機能です。
*   **Trigger**: 監視対象の式（Trigger Expression）の結果が変わったかどうかを検知します。
*   **Payload**: 変更前と変更後のデータをクライアントに送信できます。これにより、ポーリングなしでリアクティブなアプリケーションを構築できます。

---

# 6. アーキテクチャと最適化

### 6.1 O(1) コミットと遅延評価
*   **更新式の保存**: 多くのDBMSは更新時に全タプルを書き換えますが、Project:M36は「更新式（Operation）」自体をログとして追記保存します。これにより、100万行の更新であっても、ディスクへの書き込みは式の保存のみで済み、O(1)（定数時間）で完了します。
*   **遅延評価**: データが必要になる（クエリされる）まで、実際の計算やマテリアライズを行いません。

### 6.2 データ独立性とストレージ
*   **論理と物理の分離**: 論理的なリレーション定義と、ディスク上の物理表現は1対1である必要はありません。DBMSは頻繁に使用されるクエリに基づいて、インデックスやキャッシュ（マテリアライズされたビュー）を自動的に作成・選択する権限を持ちます。
*   **WORMストレージ**: データは追記型（Write-Once-Read-Many）で保存され、上書きされません。これにより、並行読み取り性能が向上し、ロック競合が減少します。

### 6.3 静的最適化 (Static Optimization)
コストベースの最適化に加え、関係代数の数学的特性を利用したルールベースの最適化を行います。
*   **恒真/恒偽の簡約**: `where true` は削除し、`where false` は空リレーションに置換します。
*   **結合除去 (Join Elimination)**: 外部キー制約が存在し、結合後に親側の属性しか使用されない場合、結合操作自体を省略します。
*   **述語プッシュダウン**: フィルタリング（Restrict）をJoinやUnionの前、あるいはProjectの後ろに移動させ、処理対象のデータ量を早期に削減します。

---

# 7. LLMがコード生成・操作する際の重要ポイント

LLMがProject:M36を操作するコード（TutorialDやHaskell）を生成する際は、以下の点に厳密に従う必要があります。

1.  **SELECT文の忘却**: SQLの`SELECT ... FROM ...`構文は使えません。代数的な操作（`join`, `where`, `{}`）の連鎖としてクエリを組み立ててください。
    *   誤: `SELECT name FROM person WHERE age > 20`
    *   正: `person where age > 20 {name}`
2.  **型の厳格さ**: 数値リテラルと属性の型は厳密に一致させる必要があります。`Integer`と`Int`は別物です。不明な場合はキャストではなく、正しい型のリテラル生成関数（`int()`, `scientific()`など）を使用してください。
3.  **NULLの扱い**: `NULL`や`IS NULL`は存在しません。欠損値を扱う必要がある場合は、事前に`Maybe`型のようなADT定義（`data MaybeInt = JustInt Int | NothingInt`）を行い、それを使用するコードを生成してください。
4.  **ネストされた集計**: `GROUP BY`のメンタルモデルを捨ててください。集計は「1. `group`で関連データをサブセットとしてネストする」→「2. `extend`でサブセットに対して集計関数（`count(@subrel)`など）を適用する」という2段階のプロセスです。
5.  **トランザクション**: 変更操作（`insert`, `update`など）を行った後は、必ず`:commit`を発行しないと、変更が永続化されず、他のセッションから見えません。
6.  **引用符**: 文字列リテラルは二重引用符 `"` です。識別子（リレーション名など）が大文字で始まる場合やスペースを含む場合はバッククォート `` ` `` で囲む必要があります。



この解説は、提供されたソースコード、ドキュメント、ブログ記事、学術的背景を統合し、Project:M36の全容を解像度高く網羅したものです。