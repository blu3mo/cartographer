---
trigger: model_decision
description: Haskellを「効果的にかつ完璧に」記述するために必要な、極めて高解像度のナレッジベース
---

このガイドは、Haskellの哲学、型システム、構文、純粋関数型プログラミングのパターン、モナドによる副作用の制御、並列・並行処理、実世界での応用（IO、DB、FFI）、そしてコンパイルモデルに至るまで、提供された資料の全領域を網羅しています。

---

# AI Coding AgentのためのHaskell完全習得マニュアル

## 1. 基礎哲学と評価モデル

### 1.1 純粋関数型プログラミングのパラダイム
*   **計算の定義:** Haskellにおける計算は、メモリ操作や命令セット（フォン・ノイマン型）ではなく、数学的な関数の適用として定義される。関数は引数を受け取り値を返すマッピングであり、副作用（状態の変更）を持たない。
*   **参照透過性:** 同じ引数に対する関数の適用は常に同じ結果を返す。これにより、コードの推論、テスト、リファクタリングが容易になる。
*   **不変性 (Immutability):** 変数は「変更可能なメモリ領域」ではなく「定義」である。一度バインドされた値は変更されない。

### 1.2 遅延評価 (Lazy Evaluation) と簡約
*   **評価戦略:** Haskellは非正格（non-strict）であり、値が必要になるまで計算を行わない。式は「サンク（thunk）」としてメモリに保持される。
*   **弱頭正規形 (WHNF):** `seq` などによる評価は、最外殻のコンストラクタ（頭部）までしか行われない（例: リストの最初のコンスセルまで）。完全に評価するには `deepseq` や `force` (NFData型クラス) を使用する必要がある。
*   **メリットとリスク:** 無限リストの扱いや制御構造の関数化が可能になる一方、サンクの蓄積によるスペースリークが発生する可能性がある。これを防ぐために `foldl'` (正格な畳み込み) や `BangPatterns` 言語拡張を使用する。

---

## 2. 型システムと型クラス

### 2.1 強固な静的型付け
*   **型推論:** 型注釈がなくてもコンパイラ（GHC）が型を推論するが、トップレベル関数には型署名を記述することが推奨される。
*   **基本型:** `Int`（固定長整数）, `Integer`（多倍長整数）, `Double`（倍精度浮動小数点）, `Char`（Unicode文字）, `Bool`（真偽値）, `()`（ユニット/空タプル）。
*   **リストとタプル:** リスト `[a]` は同種の要素の可変長シーケンス。タプル `(a, b)` は異種の要素の固定長コレクション。

### 2.2 代数的データ型 (ADT)
*   **直積型 (Product Types):** 複数の型を組み合わせる（例: `data Book = Book Int String`）。C言語の構造体に近い。
*   **直和型 (Sum Types):** 複数の選択肢を持つ（例: `data Bool = True | False`）。列挙やタグ付き共用体に近い。
*   **レコード構文:** フィールドに名前を付け、アクセサ関数を自動生成する機能。
*   **再帰型:** 自分自身を参照する型定義（例: リストや木構造）。
*   **newtype:** 既存の型をラップし、実行時のオーバーヘッドなしに別の型として扱う。型クラスのインスタンスを分ける際などに有用。

### 2.3 型クラス (Type Classes)
*   **概念:** 共通の振る舞い（等価性、順序、表示など）を定義するインターフェース。Java等のインターフェースとは異なり、既存の型に対して後から実装を追加できる（Open World Assumption）。
*   **主要な型クラス:**
    *   `Eq`: 等価判定 (`==`, `/=`)。
    *   `Ord`:順序比較 (`<`, `>`, `compare`)。
    *   `Show` / `Read`: 文字列への変換と解析。
    *   `Enum`: 列挙可能 (`succ`, `pred`, リスト範囲構文 `[1..]`)。
    *   `Bounded`: 上限と下限 (`minBound`, `maxBound`)。
    *   `Num`, `Integral`, `Floating`: 数値演算。
*   **自動導出 (Deriving):** `data ... deriving (Eq, Show)` のように記述することで、コンパイラにインスタンスを自動生成させることができる。

---

## 3. 構文と関数プログラミング技法

### 3.1 関数定義とパターンマッチ
*   **カリー化:** 全ての関数は1つの引数を取り、関数または値を返す。部分適用（Partial Application）が可能。
*   **パターンマッチ:** 引数の構造に基づいて分岐する。リストの分解 `(x:xs)` やタプルの分解に使用。ワイルドカード `_` で不要な値を無視する。
*   **ガード (Guards):** 引数の値に対する条件分岐（`| x > 0 = ...`）。
*   **Where と Let:** ローカル変数の定義。`where`は関数の最後、`let`は式の中で使用。

### 3.2 高階関数と合成
*   **高階関数:** 関数を引数に取る、または返す関数。`map`, `filter`, `foldl`, `foldr` などが代表的。
*   **関数合成:** `.` 演算子を用いて関数をつなぐ（例: `f . g` は `f(g(x))`）。ポイントフリースタイル（引数を明示しない記述）を促進する。
*   **ラムダ式:** 無名関数 `\x -> x + 1`。

---

## 4. 文脈付きの型（Functor, Applicative, Monad）

### 4.1 Functor（関手）
*   **概念:** 「コンテナ」や「文脈」の中の値に関数を適用する。`fmap` または `<$>` 演算子を使用。
*   **例:** `Maybe`（失敗するかもしれない計算）、`List`（非決定性計算）、`IO`（副作用）。

### 4.2 Applicative Functor
*   **概念:** 文脈に入った関数を、文脈に入った値に適用する。`pure` と `<*>` を使用。
*   **用途:** 多引数関数の適用（`pure f <*> x <*> y`）、並列実行の記述（解析など）。

### 4.3 Monad（モナド）
*   **概念:** 計算の連鎖を表現する。前の計算結果に基づいて次の計算を決定できる（`>>=` バインド演算子）。`do` 記法はモナドのシンタックスシュガーである。
*   **主要なモナド:**
    *   `Maybe`: 失敗の可能性。`Nothing` が発生すると以降の計算はスキップされる。
    *   `List`: 非決定性計算。リスト内包表記と同等。
    *   `IO`: 入出力。副作用を純粋関数から分離する。
    *   `Reader`: 共有環境（設定など）の読み取り。
    *   `Writer`: ログの蓄積。
    *   `State`: 状態の引き回し。
*   **モナドトランスフォーマー:** 複数のモナドの機能を積み重ねる（例: `StateT s (ReaderT r IO) a`）。`lift` を使って下層のモナドの操作を行う。

---

## 5. 高度なデータ構造とアルゴリズム

### 5.1 リストとその限界
*   リストは単方向連結リストであり、ランダムアクセスは O(n) で遅い。無限リストやストリーム処理には適している。

### 5.2 効率的な配列
*   **UArray (Unboxed Array):** プリミティブ型（Int, Double等）をメモリ上に連続して配置する。遅延評価なし、厳密評価。高速だが不変。
*   **STUArray:** `ST` モナド内で状態変更可能な配列。`runST` を使って純粋な値として取り出せる。内部で破壊的変更を行いながら、外部には参照透過性を保つ。
*   **Repa:** 多次元配列の並列処理ライブラリ。`Shape`（Z, :.）とインデックスで操作。フュージョン（中間配列の除去）により高速化。
*   **Accelerate:** GPUを使用した配列計算のための埋め込みDSL。

### 5.3 マップと集合
*   `Data.Map`, `Data.Set`: 平衡二分木で実装されており、挿入・検索は O(log n)。キーは `Ord` のインスタンスである必要がある。

### 5.4 Zipper
*   ツリーやリストなどのデータ構造の中を「移動」し、特定の場所に焦点を当てて操作するためのデータ構造。パンくずリスト（経路情報）と部分木で構成される。

---

## 6. IO、並列・並行プログラミング (The Awkward Squad)

### 6.1 IOモナドと副作用
*   **IOアクション:** `IO a` 型は、実行されると副作用（入出力）を行い、`a` 型の値を生成する「アクション」である。`main` 関数は `IO ()` 型を持つ。
*   **分離:** 純粋なコードとIOコードを分離する（Functional Core, Imperative Shell）ことで堅牢性が向上する。

### 6.2 並列性 (Parallelism) - 決定論的
*   目的: 複数のコアを使って計算を高速化する。結果は変わらない。
*   **Eval モナド:** `rpar`（並列評価のスパークを作成）と `rseq`（評価を待機）を使用。
*   **Strategies:** アルゴリズムから並列化戦略を分離する。`parList`, `parMap` など。`using` コンビネータで適用。
*   **Par モナド:** データフロー並列処理。`IVar` を使って明示的に依存関係を記述する。純粋な結果を返す (`runPar`)。

### 6.3 並行性 (Concurrency) - 非決定論的
*   目的: 複数のスレッドで独立したタスク（Webサーバーのクライアント処理など）を扱う。
*   **軽量スレッド:** `forkIO` で非常に低コストなスレッドを作成できる。
*   **MVar:** スレッド間通信のための同期変数。空か満杯の状態を持つ。ロックやチャネルとして使用。
*   **STM (Software Transactional Memory):** 複数のメモリ操作をアトミックに行う。`atomically` ブロック内で `TVar` を操作。デッドロックを防ぎ、合成可能（Composable）。
*   **非同期例外:** `throwTo` で他のスレッドに例外を投げることができる。`bracket` や `mask` を使用してリソースリークを防ぐ必要がある。

### 6.4 分散プログラミング
*   **Cloud Haskell (distributed-process):** エルラン（Erlang）に影響を受けたメッセージパッシングモデル。`Process` モナド、`send`, `expect` を使用。ノード間の通信と障害処理を行う。

---

## 7. 実践的エンジニアリングとツール

### 7.1 エラー処理
*   **部分関数:** `head` のように特定の入力でクラッシュする関数は避け、`Maybe` や `Either` を返す安全な関数を使用する。
*   **例外:** `Control.Exception` モジュール。IOモナド内でのみ捕捉可能。`try`, `catch`, `handle` を使用。
*   **ErrorT:** エラー処理機能を持つモナドトランスフォーマー。

### 7.2 テスト
*   **QuickCheck:** プロパティベーステスト。関数の満たすべき性質（例: `reverse (reverse xs) == xs`）を定義し、自動生成されたランダムなテストケースで検証する。
*   **HUnit:** 従来のユニットテスト。
*   **HPC:** コードカバレッジツール。

### 7.3 FFI (Foreign Function Interface)
*   **C言語との連携:** `foreign import ccall` でCの関数を呼び出す。`Ptr` や `ForeignPtr`（GC付きポインタ）でメモリ管理を行う。`unsafePerformIO` は純粋に見えるC関数をラップする場合にのみ慎重に使用する。

### 7.4 データフォーマットとデータベース
*   **Text / ByteString:** 文字列処理には `String`（文字のリスト）ではなく、効率的な `Text`（Unicodeテキスト）や `ByteString`（バイナリ）を使用する。
*   **JSON:** `Aeson` ライブラリを使用。`FromJSON`, `ToJSON` 型クラスと `Generic` を使った自動導出が強力。
*   **データベース:** `HDBC` (Haskell Database Connectivity) を使用。SQLデータベースへの接続、クエリ実行、トランザクション管理。

### 7.5 ビルドツール
*   **Stack:** プロジェクト管理、依存関係の解決、再現可能なビルド環境の構築。`stack new`, `stack build`, `stack test` 等のコマンドを使用。
*   **Cabal:** パッケージ記述ファイル（.cabal）。依存関係やビルドオプションを定義。

---

## 8. 高度なコンパイル理論 (Eval/Apply vs Push/Enter)

*   **Eval/Applyモデル:** 関数適用の際、関数と引数を評価する。現代の多くの関数型言語の実装で採用。
*   **Push/Enterモデル:** 引数をスタックにプッシュし、コード（クロージャ）にエンターする。GHCの初期の実装などで検討された。
*   **結論:** 現代のGHC等の実装においては、Eval/Applyモデルの方が効率的である場合が多いことが示されている。（※Source 3の詳細な理論的背景に基づく）

---

このナレッジベースは、Haskellの構文から並行処理の深いモデル、そしてコンパイラの内部挙動に至るまで、AI Coding AgentがHaskellをマスターするために必要なすべての情報を網羅しています。この情報に基づき、Agentは純粋性、型安全性、並行性を最大限に活用したHaskellコードを生成できます。