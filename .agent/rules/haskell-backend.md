---
trigger: glob
description: Haskellの基礎理論、並行並列処理、実用的なライブラリの使用法、そしてプロジェクト管理までを網羅
globs: backend/**
---

ご要望の技術スタック（Servant, Polysemy, Project:M36）は資料内には直接登場しませんが、資料で解説されている**Monad、IO処理、並行処理（STM/Async）、AesonによるJSON処理、データベース接続の抽象化、Stackによるビルド**などの知識は、これらのライブラリを使用する上で必須の基礎となります。

以下がそのプロンプトです。

***

### AIエージェントへの指示プロンプト：Servant + Polysemy + Project:M36 による Haskell Backend 開発

あなたは熟練したHaskellエンジニアです。以下の指示と、提供された参考文献の知識に基づき、**Servant**（API層）、**Polysemy**（Effectシステム）、**Project:M36**（リレーショナル代数データベース）を使用した堅牢で高パフォーマンスなバックエンドアプリケーションを設計・実装してください。

実装にあたっては、以下の参考文献から得られるベストプラクティスと理論的背景を遵守すること。

#### 1. プロジェクト構成とビルドツール
*   **ビルドツール:** `stack` を使用すること。`stack new` コマンドでプロジェクトを初期化し、`stack.yaml` で適切なresolver（LTS）を指定すること [Source: 1-Lesson 35, 6-App A]。
*   **モジュール構成:** コードは `app`（Mainモジュール）、`src`（ライブラリロジック）、`test`（テストコード）に適切に分割すること。Mainモジュールは最小限にし、ロジックはライブラリ側に記述してテスト可能にすること [Source: 1-Lesson 34, 6-Ch 5]。
*   **依存関係:** `.cabal` ファイルの `build-depends` に必要なライブラリ（`servant`, `polysemy`, `project-m36`, `aeson`, `text`, `bytestring` 等）を明記すること [Source: 6-Ch 5]。

#### 2. データ型と型システム
*   **型定義:** ドメインロジックは `data` (ADT: 代数的データ型) および `newtype` を使用して表現し、型安全性とパフォーマンス（newtypeによるオーバーヘッド削減）を確保すること [Source: 1-Lesson 12, 6-Ch 3, 6-Ch 6]。
*   **レコード構文:** データ型にはレコード構文を使用し、アクセサ関数を自動生成させること [Source: 1-Lesson 12]。
*   **文字列:** パフォーマンスのために `String` ではなく `Data.Text`（テキストデータ）および `Data.ByteString`（バイナリデータ）を使用すること。リテラルには `OverloadedStrings` 言語拡張を使用すること [Source: 6-Ch 8, 6-Ch 23]。
*   **JSON:** Servantでの通信用に、`Aeson` ライブラリを使用して `FromJSON`, `ToJSON` インスタンスを定義すること。可能な限り `DeriveGeneric` を使用してインスタンスを自動導出すること [Source: 6-Ch 5, 6-Ch 40]。

#### 3. 純粋関数と作用の分離（Polysemyの適用）
*   **純粋性:** 可能な限り関数は純粋（参照透過）に保ち、副作用（IO）を分離すること。Polysemyを使用する際は、ビジネスロジックを純粋なEffectとして定義し、IOの実装（M36クライアントとの通信など）をInterpreterとして分離すること [Source: 1-Unit 4, 6-Ch 7]。
*   **モナド:** `>>=` (bind) や `do` 記法を用いて計算を連鎖させること。モナド則（左単位元、右単位元、結合法則）を意識し、予期せぬ挙動を防ぐこと [Source: 1-Lesson 30, 2-Ch 13, 6-Ch 14]。
*   **高階関数:** `map`, `filter`, `fold` などの高階関数を駆使し、明示的な再帰を避けて簡潔なコードを書くこと [Source: 1-Unit 1, 2-Ch 5]。

#### 4. データベース接続 (Project:M36)
*   資料では `HDBC` や `sqlite-simple` が扱われているが、そのリソース管理の原則を Project:M36 に適用すること。
*   **リソース管理:** データベース接続の確立と切断には、`bracket` パターン（またはPolysemyのResource effect）を使用し、例外発生時でも確実にリソースが解放されるようにすること [Source: 5-Ch 9, 6-Ch 7, 6-Ch 21]。
*   **型変換:** データベースから取得した値とHaskellの型との変換を適切に行うこと（資料中の `FromRow` の概念を参考に、M36のAtomとHaskell型のマッピングを行う） [Source: 6-Ch 21]。

#### 5. 並行処理と非同期処理
*   **軽量スレッド:** リクエスト処理やバックグラウンドタスクには、GHCの軽量スレッド（`forkIO` または `async`）を使用すること。OSスレッドと異なり低コストであるため、接続ごとにスレッドを作成するモデル（Webサーバの基本）を採用してよい [Source: 4-30, 5-Ch 7, 5-Ch 12]。
*   **共有状態管理 (STM):** 複数のスレッドで共有する状態（キャッシュやセッション状態など）がある場合は、`MVar` ではなく **STM (Software Transactional Memory)** を使用すること。これによりデッドロックを回避し、合成可能なアトミック操作を実現すること [Source: 4-46, 5-Ch 10, 6-Ch 28]。
    *   `atomically`, `retry`, `orElse` を活用し、非ブロッキングかつ整合性のある状態更新を行うこと。
*   **非同期例外:** `async` や `cancel` を使用する場合、非同期例外に対する安全性（`mask` や `bracket` の使用）を考慮すること [Source: 5-Ch 9]。

#### 6. エラーハンドリング
*   **部分的関数の回避:** `head` や `tail` などの部分的関数（空リストでクラッシュする関数）の使用を避け、パターンマッチや `Maybe`, `Either` 型を使用して安全に処理すること [Source: 1-Lesson 38, 6-Ch 4]。
*   **例外処理:** IO層（PolysemyのInterpreter層）では `Control.Exception` を使用して例外を捕捉し、適切にハンドリングまたはログ出力を行うこと [Source: 6-Ch 19]。
*   **型によるエラー表現:** ビジネスロジックのエラーは `Either CustomErrorType a` の形式で戻り値として表現し、ランタイム例外に依存しないこと [Source: 6-Ch 19]。

#### 7. パフォーマンスと最適化
*   **遅延評価の制御:** 遅延評価によるスペースリークを防ぐため、アキュムレータを使用する際（`foldl` など）は正格評価版（`foldl'`）を使用するか、`seq` / `deepseq` / バン・パターン（`!pattern`）を用いて必要に応じて評価を強制すること [Source: 1-Lesson 24, 6-Ch 25]。
*   **プロファイリング:** パフォーマンス問題が発生した場合は、`-prof -fprof-auto -rtsopts` オプションでコンパイルし、`+RTS -p` や `-s` オプションでヒーププロファイルやGC統計情報を収集して分析すること [Source: 6-Ch 25]。

#### 8. テスト
*   **プロパティベーステスト:** `QuickCheck` を使用して、関数の不変条件（invariant）を定義し、自動生成されたテストデータで検証を行うこと。単なるユニットテストだけでなく、モデルとの整合性チェックを行うこと [Source: 6-Ch 11]。
*   **テストカバレッジ:** `stack test --coverage` 等を利用し、テストのカバレッジを確認すること。

---
**成果物:**
上記の指針に基づいた、Haskellのバックエンドコード（API定義、Effect定義、Interpreter実装、データベース接続、Main関数を含む）を出力してください。コードは可読性を重視し、各主要部分には参照した概念（例：「STMによる状態管理」「AesonによるGeneric自動導出」など）をコメントとして記述してください。